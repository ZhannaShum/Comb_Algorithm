Задача 1651 - https://acm.timus.ru/problem.aspx?space=1&num=1651
Данный код решает поставленную задачу о нахождении кратчайшей подцепи, используя алгоритм динамического программирования.

Как реализован код:
1)	Считывается число n - количество вершин в списке.
2)	Происходит инициализация словарей p и best. Словарь p будет хранить данные о подцепи q для каждой вершины, 
а best - наилучшую (наименьшую) подцепь для каждой вершины.
3) Чтение списка вершин и сохранение его в tokens. Вершины могут быть разделены пробелами или переводами строк, 
поэтому читаем их до тех пор, пока не считаем все n вершин.
4) Запоминаем конечную вершину в переменную finish.
5) Основной цикл проходит по всем вершинам в списке tokens. Внутри цикла:
 5.1) Если current равно -1, это означает, что мы находимся на начальной вершине. 
      Создаем кортеж, состоящий из 3 элементов: длина подцепи (0), номер вершины и None (так как нет предыдущей вершины). 
      Записываем кортеж в словарь p и best для данной вершины.
 5.2) В противном случае, мы обрабатываем остальные вершины. Если вершина еще не встречалась, 
      инициализируем пустой список для нее в словаре p. Создаем кортеж tmp, состоящий из длины подцепи, номера вершины и ссылки на предыдущую лучшую вершину. 
      Добавляем этот кортеж в список для текущей вершины в словаре p. Если текущая вершина еще не имеет записи в словаре best или новый кортеж tmp лучше, 
      чем текущая запись, обновляем запись в словаре best.
6) После обработки всех вершин, в словаре best для конечной вершины хранится информация о минимальной подцепи q.
7) Восстанавливаем подцепь q, используя записи в словаре best. Записываем вершины в список result. 
   Разворачиваем список и выводим его на экран.

Алгоритм работает, т.к. он рассматривает все возможные подцепи и сохраняет лучшую (минимальную) подцепь для каждой вершины. 
В конце работы алгоритма, для конечной вершины будет храниться минимальная подцепь, удовлетворяющая условиям задачи.
